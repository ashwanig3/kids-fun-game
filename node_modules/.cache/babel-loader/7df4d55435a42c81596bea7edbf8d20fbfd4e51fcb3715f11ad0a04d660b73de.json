{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BrowserDetector_1 = require(\"./BrowserDetector\");\nvar MonotonicInterpolant_1 = require(\"./MonotonicInterpolant\");\nvar ELEMENT_NODE = 1;\nfunction getNodeClientOffset(node) {\n  var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n  if (!el) {\n    return null;\n  }\n  var _a = el.getBoundingClientRect(),\n    top = _a.top,\n    left = _a.left;\n  return {\n    x: left,\n    y: top\n  };\n}\nexports.getNodeClientOffset = getNodeClientOffset;\nfunction getEventClientOffset(e) {\n  return {\n    x: e.clientX,\n    y: e.clientY\n  };\n}\nexports.getEventClientOffset = getEventClientOffset;\nfunction isImageNode(node) {\n  return node.nodeName === 'IMG' && (BrowserDetector_1.isFirefox() || !document.documentElement.contains(node));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n  var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n  var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n  // Work around @2x coordinate discrepancies in browsers\n  if (BrowserDetector_1.isSafari() && isImage) {\n    dragPreviewHeight /= window.devicePixelRatio;\n    dragPreviewWidth /= window.devicePixelRatio;\n  }\n  return {\n    dragPreviewWidth: dragPreviewWidth,\n    dragPreviewHeight: dragPreviewHeight\n  };\n}\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n  // The browsers will use the image intrinsic size under different conditions.\n  // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n  var isImage = isImageNode(dragPreview);\n  var dragPreviewNode = isImage ? sourceNode : dragPreview;\n  var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n  var offsetFromDragPreview = {\n    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n  };\n  var sourceWidth = sourceNode.offsetWidth,\n    sourceHeight = sourceNode.offsetHeight;\n  var anchorX = anchorPoint.anchorX,\n    anchorY = anchorPoint.anchorY;\n  var _a = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight),\n    dragPreviewWidth = _a.dragPreviewWidth,\n    dragPreviewHeight = _a.dragPreviewHeight;\n  var calculateYOffset = function () {\n    var interpolantY = new MonotonicInterpolant_1.default([0, 0.5, 1], [\n    // Dock to the top\n    offsetFromDragPreview.y,\n    // Align at the center\n    offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,\n    // Dock to the bottom\n    offsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);\n    var y = interpolantY.interpolate(anchorY);\n    // Work around Safari 8 positioning bug\n    if (BrowserDetector_1.isSafari() && isImage) {\n      // We'll have to wait for @3x to see if this is entirely correct\n      y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n    }\n    return y;\n  };\n  var calculateXOffset = function () {\n    // Interpolate coordinates depending on anchor point\n    // If you know a simpler way to do this, let me know\n    var interpolantX = new MonotonicInterpolant_1.default([0, 0.5, 1], [\n    // Dock to the left\n    offsetFromDragPreview.x,\n    // Align at the center\n    offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,\n    // Dock to the right\n    offsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);\n    return interpolantX.interpolate(anchorX);\n  };\n  // Force offsets if specified in the options.\n  var offsetX = offsetPoint.offsetX,\n    offsetY = offsetPoint.offsetY;\n  var isManualOffsetX = offsetX === 0 || offsetX;\n  var isManualOffsetY = offsetY === 0 || offsetY;\n  return {\n    x: isManualOffsetX ? offsetX : calculateXOffset(),\n    y: isManualOffsetY ? offsetY : calculateYOffset()\n  };\n}\nexports.getDragPreviewOffset = getDragPreviewOffset;","map":{"version":3,"names":["Object","defineProperty","exports","value","BrowserDetector_1","require","MonotonicInterpolant_1","ELEMENT_NODE","getNodeClientOffset","node","el","nodeType","parentElement","_a","getBoundingClientRect","top","left","x","y","getEventClientOffset","e","clientX","clientY","isImageNode","nodeName","isFirefox","document","documentElement","contains","getDragPreviewSize","isImage","dragPreview","sourceWidth","sourceHeight","dragPreviewWidth","width","dragPreviewHeight","height","isSafari","window","devicePixelRatio","getDragPreviewOffset","sourceNode","clientOffset","anchorPoint","offsetPoint","dragPreviewNode","dragPreviewNodeOffsetFromClient","offsetFromDragPreview","offsetWidth","offsetHeight","anchorX","anchorY","calculateYOffset","interpolantY","default","interpolate","calculateXOffset","interpolantX","offsetX","offsetY","isManualOffsetX","isManualOffsetY"],"sources":["/Users/vishalgoswami/Documents/work/my-repo/kids-fun-game/node_modules/.pnpm/react-dnd-html5-backend@6.0.0/node_modules/react-dnd-html5-backend/lib/OffsetUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BrowserDetector_1 = require(\"./BrowserDetector\");\nvar MonotonicInterpolant_1 = require(\"./MonotonicInterpolant\");\nvar ELEMENT_NODE = 1;\nfunction getNodeClientOffset(node) {\n    var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n    if (!el) {\n        return null;\n    }\n    var _a = el.getBoundingClientRect(), top = _a.top, left = _a.left;\n    return { x: left, y: top };\n}\nexports.getNodeClientOffset = getNodeClientOffset;\nfunction getEventClientOffset(e) {\n    return {\n        x: e.clientX,\n        y: e.clientY,\n    };\n}\nexports.getEventClientOffset = getEventClientOffset;\nfunction isImageNode(node) {\n    return (node.nodeName === 'IMG' &&\n        (BrowserDetector_1.isFirefox() || !document.documentElement.contains(node)));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n    var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n    var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n    // Work around @2x coordinate discrepancies in browsers\n    if (BrowserDetector_1.isSafari() && isImage) {\n        dragPreviewHeight /= window.devicePixelRatio;\n        dragPreviewWidth /= window.devicePixelRatio;\n    }\n    return { dragPreviewWidth: dragPreviewWidth, dragPreviewHeight: dragPreviewHeight };\n}\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n    // The browsers will use the image intrinsic size under different conditions.\n    // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n    var isImage = isImageNode(dragPreview);\n    var dragPreviewNode = isImage ? sourceNode : dragPreview;\n    var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n    var offsetFromDragPreview = {\n        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y,\n    };\n    var sourceWidth = sourceNode.offsetWidth, sourceHeight = sourceNode.offsetHeight;\n    var anchorX = anchorPoint.anchorX, anchorY = anchorPoint.anchorY;\n    var _a = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight), dragPreviewWidth = _a.dragPreviewWidth, dragPreviewHeight = _a.dragPreviewHeight;\n    var calculateYOffset = function () {\n        var interpolantY = new MonotonicInterpolant_1.default([0, 0.5, 1], [\n            // Dock to the top\n            offsetFromDragPreview.y,\n            // Align at the center\n            (offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,\n            // Dock to the bottom\n            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight,\n        ]);\n        var y = interpolantY.interpolate(anchorY);\n        // Work around Safari 8 positioning bug\n        if (BrowserDetector_1.isSafari() && isImage) {\n            // We'll have to wait for @3x to see if this is entirely correct\n            y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n        }\n        return y;\n    };\n    var calculateXOffset = function () {\n        // Interpolate coordinates depending on anchor point\n        // If you know a simpler way to do this, let me know\n        var interpolantX = new MonotonicInterpolant_1.default([0, 0.5, 1], [\n            // Dock to the left\n            offsetFromDragPreview.x,\n            // Align at the center\n            (offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,\n            // Dock to the right\n            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth,\n        ]);\n        return interpolantX.interpolate(anchorX);\n    };\n    // Force offsets if specified in the options.\n    var offsetX = offsetPoint.offsetX, offsetY = offsetPoint.offsetY;\n    var isManualOffsetX = offsetX === 0 || offsetX;\n    var isManualOffsetY = offsetY === 0 || offsetY;\n    return {\n        x: isManualOffsetX ? offsetX : calculateXOffset(),\n        y: isManualOffsetY ? offsetY : calculateYOffset(),\n    };\n}\nexports.getDragPreviewOffset = getDragPreviewOffset;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}